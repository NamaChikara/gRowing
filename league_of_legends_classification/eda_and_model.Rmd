---
title: "LoL: Predict Game Outcome"
author: "ZackBarry"
date: "4/22/2020"
output: 
  html_document:
   number_sections: true
   toc: true
   fig_width: 7
   fig_height: 4.5
   theme: cosmo
   highlight: tango
   code_folding: show
---

```{r setup, message = FALSE, warning = FALSE }
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(DataExplorer)
library(ggpubr)
library(leaflet)
library(leaflet.extras)
library(sqldf)
library(patchwork)
library(caret)
library(knitr)
library(DT)
library(summarytools)
library(purrr)

dataset <- read_csv("Data/high_diamond_ranked_10min.csv")
```

# Introduction

Leage of Legends is one of the most popular online multiplier games.  Two teams of 5 players compete to battle their way to their oponents' base.  From game to game, players can assume different characters and roles on their team.

The goal of this notebook is to predict the outcome of a game with data from the first 10 minutes.  Typically, games last 35min-45min, so it will be interesting to see how telling the first 10 minutes are.  The dataset contains 19 different KPIs per team across 10,000 games.  

# Pre-Modeling Stages

## Acquiring/Loading Data

We can see that the same variables are available for each the "red" and "blue" team, except `blueWins` records the outcome (there is no `redWins`).
```{r}
dataset %>% head()
```

No columns have missing data.
```{r}
map_df(dataset, function(x) { sum(is.na(x)) }) 
```

## Data Wrangling

We'd like to be able to see distributions of the winning teams' KPIs alongside the losing teams' KPIs.  Currently, the losing and winning team for each map occupy the same row.  Here we modify the data set so that each row is one team's performance in a given game:
```{r}
blue_df <- dataset %>%
  select_at(vars(-contains("red")))

red_df <- dataset %>%
  mutate(redWins = 1 - blueWins) %>%
  select_at(vars(-contains("blue")))

colnames(blue_df) <- str_replace(colnames(blue_df), "blue([a-zA-Z]*)", "\\1")
colnames(red_df) <- str_replace(colnames(red_df), "red([a-zA-Z]*)", "\\1")

long_df <- rbind(blue_df, red_df)
```

There are no values that we need to impute in this dataset.

## Visualization

### KPI Performance of Winning vs. Losing Team


First we check the correlation of each variable with Wins.  We find that gold-related KPIs `GoldDiff`, `ExperienceDiff`, `TotalGold`, and `GoldPerMin` top the list.  Experience KPIs `TotalExperience` and `AvgLevel` are slightly less correlated, as are player vs. player aggression KPIs `Kills`, `Deaths`, and `Assists`. Monster, Minion, and Ward KPIs are the least correlated.  It will be interesting to see if our Primary Component Analysis pulls these groups out.
```{r}
cor_mat <- cor(long_df)

as_tibble(cor_mat) %>%
  mutate(comparedVar = rownames(cor_mat)) %>%
  select(comparedVar, Wins) %>%
  arrange(desc(abs(Wins)))
``` 

```{r}
# Melt the correlation matrix
library(reshape2)
melted_cormat <- melt(cor_mat, na.rm = TRUE)
# Heatmap
library(ggplot2)
ggplot(data = melted_cormat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white")+
  scale_fill_gradient2(
    low = "blue", high = "red", mid = "white", 
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation"
  ) +
  theme_minimal()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 9, hjust = 1)) +
  coord_fixed() 
```


```{r}
compare_histogram <- function(df, kpi_name) {
  
  wrapr::let(
    alias = list(KPI_VAR = kpi_name),
    expr = {
      ggplot(df, aes(x = KPI_VAR, color = factor(Wins))) +
        geom_histogram(position = "identity", alpha = 0.5, fill = "white")
    }
  )

}

lapply(colnames(long_df)[-c(1:2)], compare_histogram, df = long_df)
```




